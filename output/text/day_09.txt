Title: Day 9: Git Is Your Undo Button for AI Mistakes
Day: 9
Date: Jan 9, 2026
Characters: 8073
Words: 1398
==================================================

Welcome to Day 9 of 31 Days of Vibe Coding. Today's topic is: Git Is Your Undo Button for AI Mistakes.

Claude rewrote my authentication system.

I’d asked for a small change. Add a new field to the user profile. Simple. Should have touched two files. Maybe three.

Claude touched twelve. The user model. The authentication middleware. The profile service. The registration flow. Three different API routes. Two frontend components. A migration file. And some “cleanup” I didn’t ask for.

The app crashed on startup. Errors everywhere. I spent 20 minutes trying to understand what changed. Another 30 trying to manually undo the damage.

I didn’t have a commit from before the changes. I hadn’t committed in three hours. All my working code was mixed with Claude’s changes.

Never again.

Now I commit before every significant AI operation. It takes five seconds. It’s saved me hours.

The Problem With AI Changes

AI changes are different from human changes.

When you code manually, you change one thing at a time. You test. You change another thing. You’re in control. If something breaks, you know what you just did.

AI changes come in batches. You ask for a feature, AI generates 10 files. You ask for a fix, AI rewrites a function. The changes are atomic in AI’s mind but spread across your codebase.

When those changes break something, you don’t know:

Which file has the bug

What the original code looked like

Which changes were necessary vs “helpful” extras

How to get back to working state

Without Git, you’re debugging blind.

The Workflow

Here’s the discipline that saves you:

1. Commit before asking AI to make changes

A code example with 2 lines - see the article for details.

Takes five seconds. Now you have a checkpoint.

2. Let AI make changes

Do your normal AI workflow. Generate code. Accept changes. See what happens.

3. Test

Does it work? Does it do what you wanted?

4a. If it works: commit the changes

A code example with 2 lines - see the article for details.

Clean commit message describing what changed.

4b. If it doesn’t work: decide your path

Option A: Debug and fix (if the problem is small)

Option B: Reset and try again (if the problem is big)

5. For reset: use git restore

A code example with 1 lines - see the article for details.

You’re back to your pre-AI checkpoint. No damage. No lost work. Try a different approach.

Checkpoint Commits

I use “WIP” (Work In Progress) commits as checkpoints. They’re not meant to be permanent. They’re save points.

A code example with 3 lines - see the article for details.

After the AI work is done and verified, I often squash these into cleaner commits. But during development, the checkpoints are invaluable.

Think of it like a video game. You save before the boss fight. If you die, you reload. You don’t start the whole game over.

Asking AI What Will Change

Before letting AI make big changes, ask what it plans to modify:

A code example with 2 lines - see the article for details.

AI responds with something like:

A code example with 9 lines - see the article for details.

Now you know the scope. If the list is bigger than expected, you can narrow it:

A code example with 1 lines - see the article for details.

Better to know before than discover after.

The “Show Me First” Pattern

For risky changes, ask AI to show the code without applying it:

A code example with 2 lines - see the article for details.

Claude shows you the proposed changes. You review. If it looks good:

A code example with 1 lines - see the article for details.

If it looks wrong:

A code example with 2 lines - see the article for details.

This costs a few extra messages but prevents the “AI changed everything” problem.

Smaller Commits, Better Safety

The more frequently you commit, the less you can lose.

My rhythm:

Commit before starting any AI task

Commit after any successful AI change

Commit before trying a different approach

Sometimes I commit every 10 minutes. Sometimes every 5. Depends on how much is changing.

A code example with 7 lines - see the article for details.

The final commit is clean. The WIP commits are safety nets.

Branching for Experiments

When I’m not sure if an approach will work, I branch:

A code example with 1 lines - see the article for details.

Now I can let AI go wild. If it works, merge. If it doesn’t, delete the branch.

A code example with 7 lines - see the article for details.

The main branch never gets polluted with failed experiments.

Git Diff as Review Tool

After AI makes changes, use git diff to see exactly what changed:

A code example with 1 lines - see the article for details.

This shows you every modification. Every added line. Every removed line.

Scan for:

Files you didn’t expect to change

Deletions of code you wanted to keep

Changes outside the scope you requested

If you see something wrong, now’s the time to catch it. Before you test. Before you commit. Before you forget what the original looked like.

A code example with 5 lines - see the article for details.

Reverting Specific Files

Sometimes AI changes are mostly good but one file went wrong. Revert just that file:

A code example with 2 lines - see the article for details.

Keep the good changes, undo the bad. Surgical precision.

The Stash for Quick Pivots

Sometimes you want to try something different without losing current changes:

A code example with 11 lines - see the article for details.

Stash is like a clipboard for code changes. Useful when you’re not sure which direction is right.

Prompt Template: Asking for Safe Changes

When you want AI to be careful:

A code example with 10 lines - see the article for details.

This sets expectations. AI knows the boundaries. You know what to expect in the diff.

When Things Go Really Wrong

Sometimes you need to go back further than the last commit.

A code example with 8 lines - see the article for details.

This is why frequent commits matter. More commits means more restore points.

Real Example: The Refactor Gone Wrong

I asked Claude to refactor a service for better testability. Simple request. Extract some dependencies. Add injection points.

Claude did that. It also “cleaned up” the error handling. And “simplified” some logic. And renamed some functions for “clarity.”

The tests passed. But the service behaved differently in production. A subtle change in error handling meant certain failures were silently swallowed.

I spent two hours debugging. The issue was in the “cleanup” code. Code I hadn’t asked for.

With git diff, I would have seen those extra changes. With a checkpoint commit, I could have reverted and asked for just the dependency extraction.

Now I always diff before accepting AI changes. And I commit before risky operations.

Building the Habit

This workflow feels like overhead at first. It’s not.

Time cost of frequent commits: 30 seconds per commit.

Time cost of recovering from AI mistakes without commits: 30 minutes to hours.

The math is clear. The habit takes a week to build. Then it’s automatic.

Start today:

Before any AI operation, git add -A and and git commit -m "WIP: before X"

After AI changes, git diff to review

If good, commit. If bad, restore.

That’s it. Three steps. Your safety net.

Tomorrow

Git keeps you safe from AI mistakes. But what about preventing those mistakes in the first place? Tomorrow I’ll show you how to configure AI agents with your standards. Set it up once, and every session starts with your patterns, your tech stack, your rules.

No more repeating “use TypeScript” in every conversation.

Try This Today

Before your next AI session, commit your current state

Make a checkpoint commit: git commit -m "WIP: before AI session"

Let AI make some changes

Run git diff to see exactly what changed

Practice restoring: git restore . then redo

Get comfortable with the rhythm. Commit, change, diff, decide. It’ll become second nature, and you’ll never lose hours to an AI mistake again.

That's it for Day 9. Join us tomorrow for Day 10. Thanks for listening to 31 Days of Vibe Coding.