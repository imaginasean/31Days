Title: Day 9: Git Is Your Undo Button for AI Mistakes
Day: 9
Date: Jan 9, 2026
Characters: 9202
Words: 1516
==================================================

Welcome to Day 9 of 31 Days of Vibe Coding. Today's topic is: Git Is Your Undo Button for AI Mistakes.

Claude rewrote my authentication system.

I’d asked for a small change. Add a new field to the user profile. Simple. Should have touched two files. Maybe three.

Claude touched twelve. The user model. The authentication middleware. The profile service. The registration flow. Three different API routes. Two frontend components. A migration file. And some “cleanup” I didn’t ask for.

The app crashed on startup. Errors everywhere. I spent 20 minutes trying to understand what changed. Another 30 trying to manually undo the damage.

I didn’t have a commit from before the changes. I hadn’t committed in three hours. All my working code was mixed with Claude’s changes.

Never again.

Now I commit before every significant AI operation. It takes five seconds. It’s saved me hours.

The Problem With AI Changes

AI changes are different from human changes.

When you code manually, you change one thing at a time. You test. You change another thing. You’re in control. If something breaks, you know what you just did.

AI changes come in batches. You ask for a feature, AI generates 10 files. You ask for a fix, AI rewrites a function. The changes are atomic in AI’s mind but spread across your codebase.

When those changes break something, you don’t know:

Which file has the bug

What the original code looked like

Which changes were necessary vs “helpful” extras

How to get back to working state

Without Git, you’re debugging blind.

The Workflow

Here’s the discipline that saves you:

1. Commit before asking AI to make changes

Showing git commands that stage all changes and create a work-in-progress commit before making AI-assisted modifications to authentication code.

Takes five seconds. Now you have a checkpoint.

2. Let AI make changes

Do your normal AI workflow. Generate code. Accept changes. See what happens.

3. Test

Does it work? Does it do what you wanted?

4a. If it works: commit the changes

Showing git commands that stage all changes and commit them with a message about adding an email field to a user profile.

Clean commit message describing what changed.

4b. If it doesn’t work: decide your path

Option A: Debug and fix (if the problem is small)

Option B: Reset and try again (if the problem is big)

5. For reset: use git restore

Showing a git command that discards all uncommitted changes in the current directory.

You’re back to your pre-AI checkpoint. No damage. No lost work. Try a different approach.

Checkpoint Commits

I use “WIP” (Work In Progress) commits as checkpoints. They’re not meant to be permanent. They’re save points.

Showing git commands that create work-in-progress commits to save checkpoints before making significant changes like validation, refactoring, or AI-assisted caching.

After the AI work is done and verified, I often squash these into cleaner commits. But during development, the checkpoints are invaluable.

Think of it like a video game. You save before the boss fight. If you die, you reload. You don’t start the whole game over.

Asking AI What Will Change

Before letting AI make big changes, ask what it plans to modify:

Showing a prompt that asks an AI to outline which files it plans to modify and explain its reasoning before making any actual changes.

AI responds with something like:

Showing a file checklist outlining backend changes to a user model, service, routes, and migration, plus frontend updates to a profile form and API service.

Now you know the scope. If the list is bigger than expected, you can narrow it:

Showing an instruction to only modify backend code while leaving frontend changes for later.

Better to know before than discover after.

The “Show Me First” Pattern

For risky changes, ask AI to show the code without applying it:

Showing a prompt asking an AI assistant to preview proposed code changes to a JavaScript file before applying them.

Claude shows you the proposed changes. You review. If it looks good:

Showing a brief approval message instructing to apply previously suggested changes.

If it looks wrong:

Showing a follow-up prompt asking to limit code changes to only the createUser function and requesting the revised version.

This costs a few extra messages but prevents the “AI changed everything” problem.

Smaller Commits, Better Safety

The more frequently you commit, the less you can lose.

My rhythm:

Commit before starting any AI task

Commit after any successful AI change

Commit before trying a different approach

Sometimes I commit every 10 minutes. Sometimes every 5. Depends on how much is changing.

Showing a series of git commits that incrementally document work-in-progress changes before a final polished commit message.

The final commit is clean. The WIP commits are safety nets.

Branching for Experiments

When I’m not sure if an approach will work, I branch:

Showing a git command that creates and switches to a new branch called experiment slash caching-approach.

Now I can let AI go wild. If it works, merge. If it doesn’t, delete the branch.

Showing git commands for merging an experimental caching branch into main if successful, or deleting it if not.

The main branch never gets polluted with failed experiments.

Git Diff as Review Tool

After AI makes changes, use git diff to see exactly what changed:

Showing a git command that displays unstaged changes in the working directory.

This shows you every modification. Every added line. Every removed line.

Scan for:

Files you didn’t expect to change

Deletions of code you wanted to keep

Changes outside the scope you requested

If you see something wrong, now’s the time to catch it. Before you test. Before you commit. Before you forget what the original looked like.

Showing git commands that display detailed changes in a specific file and a summary of all modified files.

Reverting Specific Files

Sometimes AI changes are mostly good but one file went wrong. Revert just that file:

Showing a git command that reverts a specific file back to its state in the last commit.

Keep the good changes, undo the bad. Surgical precision.

The Stash for Quick Pivots

Sometimes you want to try something different without losing current changes:

Showing git stash commands for saving current changes, then either dropping or restoring them based on which approach works better.

Stash is like a clipboard for code changes. Useful when you’re not sure which direction is right.

Prompt Template: Asking for Safe Changes

When you want AI to be careful:

Showing a prompt template that instructs an AI to make targeted code changes with explicit constraints and a request to explain modifications before proceeding.

This sets expectations. AI knows the boundaries. You know what to expect in the diff.

When Things Go Really Wrong

Sometimes you need to go back further than the last commit.

Showing git commands for viewing commit history and reverting to a specific commit using checkout or hard reset.

This is why frequent commits matter. More commits means more restore points.

Real Example: The Refactor Gone Wrong

I asked Claude to refactor a service for better testability. Simple request. Extract some dependencies. Add injection points.

Claude did that. It also “cleaned up” the error handling. And “simplified” some logic. And renamed some functions for “clarity.”

The tests passed. But the service behaved differently in production. A subtle change in error handling meant certain failures were silently swallowed.

I spent two hours debugging. The issue was in the “cleanup” code. Code I hadn’t asked for.

With git diff, I would have seen those extra changes. With a checkpoint commit, I could have reverted and asked for just the dependency extraction.

Now I always diff before accepting AI changes. And I commit before risky operations.

Building the Habit

This workflow feels like overhead at first. It’s not.

Time cost of frequent commits: 30 seconds per commit.

Time cost of recovering from AI mistakes without commits: 30 minutes to hours.

The math is clear. The habit takes a week to build. Then it’s automatic.

Start today:

Before any AI operation, git add -A and and git commit -m "WIP: before X"

After AI changes, git diff to review

If good, commit. If bad, restore.

That’s it. Three steps. Your safety net.

Tomorrow

Git keeps you safe from AI mistakes. But what about preventing those mistakes in the first place? Tomorrow I’ll show you how to configure AI agents with your standards. Set it up once, and every session starts with your patterns, your tech stack, your rules.

No more repeating “use TypeScript” in every conversation.

Try This Today

Before your next AI session, commit your current state

Make a checkpoint commit: git commit -m "WIP: before AI session"

Let AI make some changes

Run git diff to see exactly what changed

Practice restoring: git restore . then redo

Get comfortable with the rhythm. Commit, change, diff, decide. It’ll become second nature, and you’ll never lose hours to an AI mistake again.

That's it for Day 9. Join us tomorrow for Day 10. Thanks for listening to 31 Days of Vibe Coding.